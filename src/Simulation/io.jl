"""
    rtr2mat(rtr, outfile; force)

Write the [`RaftTrajectory`](@ref) in `rtr` to `outfile` which must be a `.mat` file.

This writes the raw, unbinned trajectory data.

### Optional Arguments

- `force`: If `true`, delete `outfile` if it already exists. Default `false`.
"""
function rtr2mat(rtr::RaftTrajectory, outfile::String; force::Bool = false)

    @argcheck endswith(outfile, ".mat") "Must output a .mat file."
    !force && @argcheck !isfile(outfile) "This file already exists. Pass `force = true` to overwrite it."

    matdict_t = rtr.t
    matdict_n_clumps = rtr.n_clumps
    matdict_com = [rtr.com.xy ;; rtr.com.t]
    matdict_info = "The trajectory data is a matrix with N rows and 4 columns. 

    Each row is a data point of the form (i, x, y, t) where i is the index of the clump.

    Time t is measured in $(UNITS["time"]) since $(T_REF.x)." 

    matdict_traj = Vector{Vector{Float64}}()
    for clump_id in sort(collect(keys(rtr.trajectories)))
        traj = rtr.trajectories[clump_id]
        for i = 1:length(traj.t)
            push!(matdict_traj, [clump_id, traj.xy[i,1], traj.xy[i,2], traj.t[i]])
        end
    end

    matdict_traj = stack(matdict_traj, dims = 1)

    mat_dict = Dict(
        "trajectories" => matdict_traj,
        "times" => matdict_t,
        "n_clumps" => matdict_n_clumps,
        "com" => matdict_com,
        "info" => matdict_info)

    isfile(outfile) && rm(outfile)
    matwrite(outfile, mat_dict)

    return nothing
end

function _rtr2nc(outfile, data, times, lons, lats)
    lonatts = Dict(
        "longname" => "Longitude",
        "units"    => "degrees east",
        "min"      => minimum(lons),
        "max"      => maximum(lons))
    latatts = Dict(
        "longname" => "Latitude",
        "units"    => "degrees north",
        "min"      => minimum(lats),
        "max"      => maximum(lats))
    timeatts = Dict(
        "longname" => "Time",
        "units"    => "$(UNITS["time"]) since $(T_REF.x)",
        "example"  => "time = 6677 is $(time2datetime(6677))",
        "min"      => minimum(times),
        "max"      => maximum(times),
        "min_datetime"      => string(minimum(time2datetime.(times))),
        "max_datetime"      => string(maximum(time2datetime.(times))))
    
    data_atts = Dict(
        "longname" => "Trajectory counts",
        "units"    => "number")
    
    # writing to file
    isfile(outfile) && rm(outfile)
    
    nccreate(outfile, 
        "data",
        "lon", lons, lonatts,
        "lat", lats, latatts, 
        "time", times, timeatts, 
        atts = data_atts,
        gatts = Dict(
            "info" =>       "This file was generated by the Julia package SargassumBOMB.jl. It contains trajectory counts of Sargassum clumps.",
            "github" =>     "https://github.com/70Gage70/SargassumBOMB.jl"),
        t = UInt16)
    
    ncwrite(data, outfile, "data")

    return nothing
end

"""
    rtr2nc(rtr, outfile, lon_bins, lat_bins; force)

Write the [`RaftTrajectory`](@ref) in `rtr` to `outfile` which must be a `.nc` file.

The data are binned by passing `lon_bins` and `lat_bins` to [`bins`](@ref).

It is required that `rtr.t` is linearly spaced.

### Optional Arguments

- `force`: If `true`, delete `outfile` if it already exists. Default `false`.
"""
function rtr2nc(rtr::RaftTrajectory, outfile::String, lon_bins::StepRangeLen, lat_bins::StepRangeLen; force::Bool = false)
    try 
        vec2range(rtr.t)
    catch
        error("`rtr.t` must be linearly spaced.")
    end

    @argcheck endswith(outfile, ".nc") "Must output a .nc file."
    !force && @argcheck !isfile(outfile) "This file already exists. Pass `force = true` to overwrite it."

    times = rtr.t
    data = zeros(UInt16, length(lon_bins)-1, length(lat_bins)-1, length(times))

    for i = 1:length(times)
        data[:,:,i] .= Integer.(bins(time_slice(rtr, (times[i], times[i])), lon_bins, lat_bins))
    end
    
    lons = [(lon_bins[i + 1] + lon_bins[i])/2 for i = 1:length(lon_bins) - 1]
    lats = [(lat_bins[i + 1] + lat_bins[i])/2 for i = 1:length(lat_bins) - 1]
    
    _rtr2nc(outfile, data, times, lons, lats)

    return nothing
end

"""
    rtr2nc(rtr, outfile, dist; force)

Write the [`RaftTrajectory`](@ref) in `rtr` to `outfile` which must be a `.nc` file.

The data are binned by passing `dist` to [`bins`](@ref), i.e. the bins are chosen to be the same
as the bins of `dist`.

It is required that `rtr.t` is linearly spaced.

### Optional Arguments

- `force`: If `true`, delete `outfile` if it already exists. Default `false`.
"""
function rtr2nc(rtr::RaftTrajectory, outfile::String, dist::SargassumDistribution; force::Bool = false)
    try 
        vec2range(rtr.t)
    catch
        error("`rtr.t` must be linearly spaced.")
    end

    @argcheck endswith(outfile, ".nc") "Must output a .nc file."
    !force && @argcheck !isfile(outfile) "This file already exists. Pass `force = true` to overwrite it."

    lons = dist.lon
    lats = dist.lat

    times = rtr.t
    data = zeros(UInt16, length(lons), length(lats), length(times))

    for i = 1:length(times)
        data[:,:,i] .= Integer.(bins(time_slice(rtr, (times[i], times[i])), dist))
    end
    
    _rtr2nc(outfile, data, times, lons, lats)

    return nothing
end

function _dict(cp::ClumpParameters)
    Dict(
        "cp_alpha" => cp.α,
        "cp_tau" => cp.τ,
        "cp_R" => cp.R,
        "cp_omega" => cp.Ω,
        "cp_sigma" => cp.σ
    )
end

function _dict(ics::InitialConditions)
    Dict(
        "ics_ics" => ics.ics,
        "ics_tspan" => ics.tspan |> collect # .mat files need vectors
    )
end

function _dict(spring::AbstractSpring)
    fnames = fieldnames(typeof(spring)) |> n -> filter(x -> x != :k, n)
    d = Dict{String, Any}()
    for n in fnames
        d["sp_" * string(n)] = getfield(spring, n)
    end
    d["sp_k_at_1"] = spring.k(1.0)
    d["sp_type"] = string(typeof(spring).name.name)

    return d
end

function _dict(cons::AbstractConnections)
    fnames = fieldnames(typeof(cons)) |> n -> filter(x -> x != :connections, n)
    d = Dict{String, Any}()
    for n in fnames
        d["connecs_" * string(n)] = getfield(cons, n)
    end
    d["connecs_type"] = string(typeof(cons))
    return d
end

function _dict(gd_model::ImmortalModel)
    return Dict("gd_model" => "ImmortalModel")
end

function _dict(gd_model::BrooksModel)
    p = gd_model.params
    exclusions = [:temp, :no3, :dSdt]
    fnames = fieldnames(typeof(p)) |> n -> filter(x -> !(x in exclusions), n)
    d = Dict{String, Any}()
    for n in fnames
        d["gd_" * string(n)] = getfield(p, n)
    end
    d["gd_type"] = "BrooksModel"
    return d
end

function _dict(rp::RaftParameters)
    d = Dict{String, Any}()
    merge!(d, _dict(rp.clumps))
    merge!(d, _dict(rp.ics))
    merge!(d, _dict(rp.springs))
    merge!(d, _dict(rp.connections))
    merge!(d, _dict(rp.gd_model))
    d["geometry"] = rp.geometry
    d["n_clumps_max"] = rp.n_clumps_max
    d["INFO_GENERAL"] = "connecs_ = AbstractConnections, \
        cp_ = ClumpParameters, \
        gd_model = AbstractGrowthDeathModel, \
        geometry = RaftParameters.geometry, \
        ics_ = InitialConditions, \
        n_clumps_max = RaftParameters.n_clumps_max, \
        sp_ = AbstractSpring"
    d["INFO_SPECIFIC"] = "sp_k_at_1 is the spring stiffness function evaluated with an argument of 1."

    return d
end

# create a mat file with "serialized" values of a `RaftParameters` object
function _rp2mat(rp::RaftParameters, outfile::String; force::Bool = false)

    @argcheck endswith(outfile, ".mat") "Must output a .mat file."
    !force && @argcheck !isfile(outfile) "This file already exists. Pass `force = true` to overwrite it."

    isfile(outfile) && rm(outfile)
    matwrite(outfile, _dict(rp))

    return nothing
end

# append to a mat file the "serialized" values of a `RaftParameters` object
function _rp2mat!(rp::RaftParameters, outfile::String)
    @argcheck endswith(outfile, ".mat") "The target file must be a .mat file."
    @argcheck isfile(outfile) "The target file must already exist."

    d = merge(matread(outfile), _dict(rp))
    matwrite(outfile, d)

    return nothing
end